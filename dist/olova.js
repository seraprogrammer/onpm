const e=Symbol("BATCH_UPDATES"),t=Symbol("SIGNAL_TYPE");class n{constructor(){this.globalSubs=new Set,this.propSubs=new Map,this.weakPropSubs=new WeakMap,this.dependencies=new WeakMap,this.batchMode=!1,this.pendingDeps=new Set}subscribe(e,t){if(!t)return;this.dependencies.has(t)||this.dependencies.set(t,new Set);const n=this.dependencies.get(t);if(!n.has(e)){if(n.add(e),!e)return void this.globalSubs.add(t);const i="object"==typeof e?this.weakPropSubs:this.propSubs;i.has(e)||i.set(e,new Set),i.get(e).add(t)}}notify(e,t=new Set){if(this.batchMode)return this.pendingDeps.add(e),t;if(e){const n=this.propSubs.get(e);if(n&&this.notifyDependentSubs(n,e,t),"object"==typeof e){const n=this.weakPropSubs.get(e);n&&this.notifyDependentSubs(n,e,t)}}return this.notifyDependentSubs(this.globalSubs,e,t),t}startBatch(){this.batchMode=!0,this.pendingDeps.clear()}endBatch(){this.batchMode=!1;const e=new Set;for(const t of this.pendingDeps)this.notify(t,e);return this.pendingDeps.clear(),e}notifyDependentSubs(e,t,n){for(const i of e)if(!n.has(i)){const e=this.dependencies.get(i);t&&e&&!e.has(t)||(i(),n.add(i))}}cleanup(e){if(e){this.propSubs.delete(e);for(const[t,n]of this.dependencies)n.delete(e),0===n.size&&this.dependencies.delete(t)}}}class i{constructor(){this.updates=new Map,this.priorities=new Map,this.timeouts=new Map,this.debounceTime=16}add(e,t,n=0,i=!1){if(i)return this.timeouts.has(e)&&clearTimeout(this.timeouts.get(e)),void this.timeouts.set(e,setTimeout((()=>{this.addImmediate(e,t,n),this.timeouts.delete(e)}),this.debounceTime));this.addImmediate(e,t,n)}addImmediate(e,t,n){if(this.updates.has(e)){const i=this.updates.get(e),o=this.priorities.get(e)||0;"object"==typeof i&&"object"==typeof t&&(t={...i,...t}),n=Math.max(o,n)}this.updates.set(e,t),this.priorities.set(e,n)}process(e){0!==this.updates.size&&(this.timeouts.size>0?Promise.all(Array.from(this.timeouts.values()).map((e=>new Promise((t=>{const n=setInterval((()=>{this.timeouts.has(e)||(clearInterval(n),t())}),0)}))))).then((()=>this.processImmediate(e))):this.processImmediate(e))}processImmediate(e){const t=[...this.updates.entries()].sort(((e,t)=>(this.priorities.get(t[0])||0)-(this.priorities.get(e[0])||0)));e.startBatch();const n=new Set;for(const[i,o]of t)"function"==typeof o&&o(),e.notify(i,n);e.endBatch(),this.updates.clear(),this.priorities.clear()}clear(){this.timeouts.forEach((e=>clearTimeout(e))),this.timeouts.clear(),this.updates.clear(),this.priorities.clear()}}const o=(o,r={})=>{const{equals:s=Object.is,immediate:a=!0,batched:c=!1,debounce:l=!1}=r;let d=o;const u=new n,f=new i,h=e=>{const t=p();return t&&u.subscribe(e,t),e?d[e]:d};return h[e]=()=>(u.startBatch(),()=>{u.endBatch(),f.clear()}),h[t]=!0,[h,(e,t,n=0)=>{const i="function"==typeof e?e(t?d[t]:d):e;(t?!s(d[t],i):!s(d,i))&&(d=t?{...d,[t]:i}:i,c?(f.add(t,i,n,l),queueMicrotask((()=>{f.process(u)}))):u.notify(t))}]};function r(e,t={defer:!1}){let n=null,i=new Set,o=new Set;const r=()=>{n&&n(),o.forEach((e=>e())),o.clear(),i.clear(),h=r;try{n=e()||null}finally{h=null}};return t.defer||r(),r}function s(e){const t=p();if(!t)throw new Error("onCleanup must be called within a reactive context");if(!t.cleanupFns)return e;t.cleanupFns.add(e)}function a(e,t={}){const[n,i]=o(void 0,t);let s=!1,a=new Set;return r((()=>{a.clear();const o=e();s&&t.equals&&t.equals(n(),o)||(i(o),s=!0)})),n}function c(e,t={}){const{initialValue:n=null,cacheTime:i=5e3,retries:r=3,retryDelay:s=1e3,lazy:a=!1}=t,[c,l]=o(n),[d,u]=o(!1),[f,h]=o(null);let p=new Map,m=new Map,g=0;const y=e=>{e?(p.delete(e),m.has(e)&&(clearTimeout(m.get(e)),m.delete(e))):(p.clear(),m.forEach((e=>clearTimeout(e))),m.clear())},b=async t=>{const n=JSON.stringify(t);if(p.has(n))return p.get(n);u(!0),h(null),g=0;const o=async()=>{try{const o=await e(t);return l(o),p.set(n,o),i>0&&m.set(n,setTimeout((()=>y(n)),i)),o}catch(e){if(g<r)return g++,await new Promise((e=>setTimeout(e,s*g))),o();throw h(e),e}finally{u(!1)}};return o()};return a||b(),{data:c,loading:d,error:f,refetch:b,clearCache:y}}new Map;function l(e,n,...i){const o="http://www.w3.org/2000/svg",s=new Set(["svg","path","circle","rect","line","polygon","polyline","ellipse","g","text","tspan","defs","use","mask","clipPath"]);if("function"==typeof e)return e({...n,children:i});if(e===d){const e=document.createDocumentFragment();return i.flat().forEach((t=>{const n=w(t);n&&e.appendChild(n)})),e}if("string"!=typeof e)throw new Error(`Invalid element type: ${e}`);const a=s.has(e.toLowerCase())||n&&n.xmlns===o,c=a?document.createElementNS(o,e):document.createElement(e);if(n)for(const[e,i]of Object.entries(n))if("ref"===e)"function"==typeof i?i(c):i&&(i.current=c);else if(e.startsWith("on")){const t=e.slice(2).toLowerCase();c.addEventListener(t,i)}else if("style"===e)"string"==typeof i?c.style.cssText=i:Object.assign(c.style,i);else if("classList"===e){if(Array.isArray(i))c.classList.add(...i.filter(Boolean));else if("object"==typeof i)for(const[e,t]of Object.entries(i))t?c.classList.add(e):c.classList.remove(e)}else"class"===e||"className"===e?c.setAttribute("class",i):["key"].includes(e)||("function"==typeof i&&i[t]?r((()=>{a?c.setAttribute(e,i()):c[e]=i()})):a?!0===i?c.setAttribute(e,""):!1!==i&&null!=i&&c.setAttribute(e,i):c[e]=i);return i.flat().forEach((e=>{if(null==e)return;const t=w(e);t&&(a&&t instanceof SVGElement||t instanceof Node?c.appendChild(t):c.appendChild(document.createTextNode(String(t))))})),c}const d=Symbol("Fragment");function u(t,n,i={}){const{hydrate:r=!1,onError:s=console.error,suspense:a=!0,beforeMount:c,afterMount:l}=i;if(!r)for(;n.firstChild;)n.removeChild(n.firstChild);const[d]=o(null),u=d[e]();c?.();try{let e=t();if(a&&e instanceof Promise)return void e.then((e=>{f(e,n,r),l?.()})).catch(s);f(e,n,r),l?.()}catch(e){s(e)}finally{u()}return()=>{for(;n.firstChild;)n.removeChild(n.firstChild)}}function f(e,t,n){if(!e)return;const i=Array.isArray(e)?e.flat(1/0):[e],o=Array.from(t.childNodes);let r=0;if(i.filter(Boolean).forEach((e=>{"string"==typeof e||"number"==typeof e?n&&o[r]?.nodeType===Node.TEXT_NODE?o[r].textContent=String(e):t.appendChild(document.createTextNode(String(e))):e instanceof Node?n&&o[r]?e.isEqualNode(o[r])||t.replaceChild(e,o[r]):t.appendChild(e):Array.isArray(e)?f(e,t,n):e&&"object"==typeof e&&t.appendChild(document.createTextNode(JSON.stringify(e))),r++})),!n)for(;r<o.length;)t.removeChild(o[r]),r++}let h=null;const p=()=>h;function m(e){const t=Symbol("context");new Map;return{Provider:({value:e,children:n})=>{const i=g(t);h=e;return h=i,n},Context:t,defaultValue:e}}function g(e){return h||e.defaultValue}function y({fallback:e,children:t}){try{return t}catch(t){return e(t)}}function b(e){let t=null,n=null;return function(i){if(!t)throw n||(n=e().then((e=>{t=e.default||e}))),n;return l(t,i)}}function S(e=null){return{current:e}}"undefined"!=typeof window?(window.h=l,window.Fragment=d):"undefined"!=typeof global&&(global.h=l,global.Fragment=d);export{o as createSignal,r as createEffect,a as createMemo,c as createResource,m as createContext,g as useContext,l as h,d as Fragment,u as render,y as ErrorBoundary,b as lazy,s as onCleanup,S as createRef};export default{h:l,Fragment:d};const w=e=>{if(null==e||!1===e||!0===e)return null;const n=()=>{const e=Math.random().toString(36).slice(2,8),t=document.createComment(`start:${e}`),n=document.createComment(`end:${e}`),i=document.createDocumentFragment();return i.appendChild(t),i.appendChild(n),{fragment:i,startNode:t,endNode:n}};if("function"==typeof e){const{fragment:i,startNode:o,endNode:s}=n();let a=null,c=null;return r((()=>{let n=(e[t],e());if(null!=n&&!1!==n&&!0!==n||(n=null),n===c)return;if(a){if(a.nodeType===Node.TEXT_NODE&&("string"==typeof n||"number"==typeof n)){const e=String(n);return a.textContent!==e&&(a.textContent=e),void(c=n)}if(a instanceof Element&&n instanceof Element&&a.tagName===n.tagName){const e=a.attributes,t=n.attributes;for(const t of e)n.hasAttribute(t.name)||a.removeAttribute(t.name);for(const e of t)a.getAttribute(e.name)!==e.value&&a.setAttribute(e.name,e.value);if(a.childNodes.length===n.childNodes.length){let e=!1;for(let t=0;t<a.childNodes.length;t++){const i=a.childNodes[t],o=n.childNodes[t];if(i.nodeType!==Node.TEXT_NODE||o.nodeType!==Node.TEXT_NODE){e=!0;break}i.textContent!==o.textContent&&(i.textContent=o.textContent)}if(!e)return void(c=n)}}}const i=s.parentNode,r=document.createDocumentFragment();if(null!=n){const e=N(n);e&&r.appendChild(e)}if(o.nextSibling!==s){let e=o.nextSibling;const t=[];for(;e&&e!==s;)t.push(e),e=e.nextSibling;t.forEach((e=>e.remove()))}r.firstChild?(i.insertBefore(r,s),a=o.nextSibling):a=null,c=n})),i}if(Array.isArray(e)){const{fragment:t,startNode:i,endNode:o}=n();let s=[],a=new Map;return r((()=>{const t=e.filter(Boolean);if(0===t.length){if(0===s.length)return;let e=i.nextSibling;const t=[];for(;e&&e!==o;)t.push(e),e=e.nextSibling;return t.forEach((e=>e.remove())),s=[],void a.clear()}if(s.length===t.length&&s.length<5){let e=!1;const n=[];let r=i.nextSibling;for(;r&&r!==o;)n.push(r),r=r.nextSibling;for(let i=0;i<t.length;i++){const o=s[i],r=t[i],a=n[i];if(o!==r){if(a.nodeType!==Node.TEXT_NODE||"string"!=typeof r&&"number"!=typeof r){e=!0;break}a.textContent=String(r)}}if(!e)return void(s=[...t])}const n=document.createDocumentFragment(),r=new Map;t.forEach(((e,t)=>{const i=e?.key||`${typeof e}:${String(e)}`;let o;a.has(i)?(o=a.get(i),a.delete(i)):o=w(e),o&&(r.set(i,o),n.appendChild(o))})),a.clear(),a=r;let c=i.nextSibling;const l=[];for(;c&&c!==o;)l.push(c),c=c.nextSibling;l.forEach((e=>e.remove())),o.parentNode.insertBefore(n,o),s=[...t]})),t}return e instanceof Node?e:document.createTextNode(String(e))},N=e=>{if(Array.isArray(e)){const t=document.createDocumentFragment();return e.forEach((e=>{const n=w(e);n&&t.appendChild(n)})),t}return e instanceof Node?e:document.createTextNode(String(e))};
